from typing import Callable, ClassVar, List, Tuple

from typing import overload
import numpy

class Causal:
    def __init__(self) -> None: ...
    def CausalCone(self, arg0: QuantumCircuit, arg1: Observable) -> complex: ...

class DensityMatrix(QuantumStateBase):
    def __init__(self, qubit_count: int) -> None: ...
    def add_state(self, state: QuantumStateBase) -> None: ...
    def allocate_buffer(self) -> QuantumStateBase: ...
    def copy(self) -> QuantumStateBase: ...
    def get_classical_value(self, index: str) -> int: ...
    def get_device_type(self) -> DeviceType: ...
    def get_entropy(self) -> float: ...
    def get_marginal_probability(self, measured_value: List[int]) -> float: ...
    def get_matrix(self) -> numpy.ndarray[numpy.complex128[m,n]]: ...
    def get_squared_norm(self) -> float: ...
    def get_zero_probability(self, index: int) -> float: ...
    @overload
    def load(self, state: QuantumStateBase) -> None: ...
    @overload
    def load(self, state: List[complex]) -> None: ...
    @overload
    def load(self, state: numpy.ndarray[numpy.complex128[m,n]]) -> None: ...
    def multiply_coef(self, coef: complex) -> None: ...
    def normalize(self, squared_norm: float) -> None: ...
    @overload
    def sampling(self, count: int) -> List[int]: ...
    @overload
    def sampling(self, count: int, seed: int) -> List[int]: ...
    @overload
    def set_Haar_random_state(self) -> None: ...
    @overload
    def set_Haar_random_state(self, seed: int) -> None: ...
    def set_classical_value(self, index: str, value: int) -> None: ...
    def set_computational_basis(self, index: int) -> None: ...
    def set_zero_state(self) -> None: ...
    def to_string(self) -> str: ...

class FermionOperator:
    def __init__(self) -> None: ...
    @overload
    def add_term(self, coef: complex, fermion_operator: SingleFermionOperator) -> None: ...
    @overload
    def add_term(self, coef: complex, action_string: str) -> None: ...
    def copy(self) -> FermionOperator: ...
    def get_coef_list(self) -> List[complex]: ...
    def get_fermion_list(self) -> List[SingleFermionOperator]: ...
    def get_term(self, index: int) -> Tuple[complex,SingleFermionOperator]: ...
    def get_term_count(self) -> int: ...
    def __IMUL__(self, arg0: complex) -> FermionOperator: ...
    def __add__(self, arg0: FermionOperator) -> FermionOperator: ...
    def __iadd__(self, arg0: FermionOperator) -> FermionOperator: ...
    def __imul__(self, arg0: FermionOperator) -> FermionOperator: ...
    def __isub__(self, arg0: FermionOperator) -> FermionOperator: ...
    @overload
    def __mul__(self, arg0: FermionOperator) -> FermionOperator: ...
    @overload
    def __mul__(self, arg0: complex) -> FermionOperator: ...
    def __sub__(self, arg0: FermionOperator) -> FermionOperator: ...

class NoiseSimulator:
    def __init__(self, arg0: QuantumCircuit, arg1: StateVectorCpu) -> None: ...
    def execute(self, arg0: int) -> List[int]: ...

class Observable:
    def __init__(self) -> None: ...
    @overload
    def add_term(self, coef: complex, pauli_operator: PauliOperator) -> None: ...
    @overload
    def add_term(self, coef: complex, pauli_string: str) -> None: ...
    def copy(self) -> Observable: ...
    def get_expectation_value(self, state: QuantumStateBase) -> complex: ...
    def get_term(self, index: int) -> Tuple[complex,PauliOperator]: ...
    def get_term_count(self) -> int: ...
    def get_transition_amplitude(self, state_bra: QuantumStateBase, state_ket: QuantumStateBase) -> complex: ...
    def __IMUL__(self, arg0: complex) -> Observable: ...
    def __add__(self, arg0: Observable) -> Observable: ...
    def __iadd__(self, arg0: Observable) -> Observable: ...
    def __imul__(self, arg0: Observable) -> Observable: ...
    def __isub__(self, arg0: Observable) -> Observable: ...
    @overload
    def __mul__(self, arg0: Observable) -> Observable: ...
    @overload
    def __mul__(self, arg0: complex) -> Observable: ...
    def __sub__(self, arg0: Observable) -> Observable: ...

class PauliOperator:
    __hash__: ClassVar[None] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, qubit_index: List[int], pauli_id: List[int]) -> None: ...
    @overload
    def __init__(self, pauli_string: str) -> None: ...
    def add_single_Pauli(self, index: int, pauli_string: int) -> None: ...
    def copy(self) -> PauliOperator: ...
    def get_expectation_value(self, state: QuantumStateBase) -> complex: ...
    def get_index_list(self) -> List[int]: ...
    def get_pauli_id_list(self) -> List[int]: ...
    def get_transition_amplitude(self, state_bra: QuantumStateBase, state_ket: QuantumStateBase) -> complex: ...
    def __eq__(self, arg0: PauliOperator) -> bool: ...
    def __imul__(self, arg0: PauliOperator) -> PauliOperator: ...
    def __mul__(self, arg0: PauliOperator) -> PauliOperator: ...

class QuantumCircuit:
    def __init__(self, qubit_count: int) -> None: ...
    @overload
    def add_gate(self, gate: QuantumGateBase) -> None: ...
    @overload
    def add_gate(self, gate: QuantumGateBase, position: int) -> None: ...
    def calculate_depth(self) -> int: ...
    def copy(self) -> QuantumCircuit: ...
    def dump_as_byte(self) -> bytes: ...
    def get_gate(self, position: int) -> QuantumGateBase: ...
    def get_gate_count(self) -> int: ...
    def get_qubit_count(self) -> int: ...
    def load_from_byte(self, arg0: str) -> None: ...
    def merge_circuit(self, circuit: QuantumCircuit) -> None: ...
    def remove_gate(self, position: int) -> None: ...
    def to_string(self) -> str: ...
    @overload
    def update_quantum_state(self, state: QuantumStateBase) -> None: ...
    @overload
    def update_quantum_state(self, state: QuantumStateBase, start: int, end: int) -> None: ...

class QuantumGateBase:
    def __init__(self, *args, **kwargs) -> None: ...
    def copy(self) -> QuantumGateBase: ...
    def dump_as_byte(self) -> bytes: ...
    def get_control_index_list(self) -> List[int]: ...
    def get_matrix(self) -> numpy.ndarray[numpy.complex128[m,n]]: ...
    def get_target_index_list(self) -> List[int]: ...
    def load_from_byte(self, arg0: str) -> None: ...
    def to_string(self) -> str: ...
    def update_quantum_state(self, state: QuantumStateBase) -> None: ...

class QuantumGateBasic(QuantumGateBase):
    def __init__(self, *args, **kwargs) -> None: ...
    def add_control_qubit(self, index: int, control_value: int) -> None: ...
    def copy(self) -> QuantumGateBase: ...
    def dump_as_byte(self) -> bytes: ...
    def get_matrix(self) -> numpy.ndarray[numpy.complex128[m,n]]: ...
    def load_from_byte(self, arg0: str) -> None: ...
    def multiply_scalar(self, value: complex) -> None: ...
    def to_string(self) -> str: ...
    def update_quantum_state(self, state: QuantumStateBase) -> None: ...

class QuantumGateWrapped(QuantumGateBase):
    def __init__(self, *args, **kwargs) -> None: ...
    def copy(self) -> QuantumGateBase: ...
    def dump_as_byte(self) -> bytes: ...
    def get_matrix(self) -> numpy.ndarray[numpy.complex128[m,n]]: ...
    def load_from_byte(self, arg0: str) -> None: ...
    def to_string(self) -> str: ...
    def update_quantum_state(self, state: QuantumStateBase) -> None: ...

class QuantumStateBase:
    def __init__(self, *args, **kwargs) -> None: ...

class SingleFermionOperator:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, target_index_list: List[int], action_id_list: List[int]) -> None: ...
    @overload
    def __init__(self, action_string: str) -> None: ...
    def get_action_id_list(self) -> List[int]: ...
    def get_target_index_list(self) -> List[int]: ...
    def __imul__(self, arg0: SingleFermionOperator) -> SingleFermionOperator: ...
    def __mul__(self, arg0: SingleFermionOperator) -> SingleFermionOperator: ...

class StateVectorCpu(QuantumStateBase):
    def __init__(self, qubit_count: int) -> None: ...
    def add_state(self, state: QuantumStateBase) -> None: ...
    def allocate_buffer(self) -> QuantumStateBase: ...
    def copy(self) -> QuantumStateBase: ...
    def get_classical_value(self, index: str) -> int: ...
    def get_device_type(self) -> DeviceType: ...
    def get_entropy(self) -> float: ...
    def get_marginal_probability(self, measured_value: List[int]) -> float: ...
    def get_qubit_count(self) -> int: ...
    def get_squared_norm(self) -> float: ...
    def get_vector(self) -> numpy.ndarray[numpy.complex128[m,1]]: ...
    def get_zero_probability(self, index: int) -> float: ...
    @overload
    def load(self, state: QuantumStateBase) -> None: ...
    @overload
    def load(self, state: List[complex]) -> None: ...
    def multiply_coef(self, coef: complex) -> None: ...
    def multiply_elementwise_function(self, func: Callable[[int],complex]) -> None: ...
    def normalize(self, squared_norm: float) -> None: ...
    @overload
    def sampling(self, count: int) -> List[int]: ...
    @overload
    def sampling(self, count: int, seed: int) -> List[int]: ...
    @overload
    def set_Haar_random_state(self) -> None: ...
    @overload
    def set_Haar_random_state(self, seed: int) -> None: ...
    def set_classical_value(self, index: str, value: int) -> None: ...
    def set_computational_basis(self, index: int) -> None: ...
    def set_zero_state(self) -> None: ...
    def to_string(self) -> str: ...

def StateVector(arg0: int) -> StateVectorCpu: ...
